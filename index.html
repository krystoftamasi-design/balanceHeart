<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HeathBalance</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://use.typekit.net/wak8lgu.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
 
</head>
<body> 
 
  
  <div class="grid-wrapper">
    <div class="grid-container">
    
    <div class="logo-cell"></div>  

    <div class="item_hvezda-cell"></div>
    <div class="item_hvezda-cell2"></div>
    
    <div class="item_sipka_dole2-cell"></div>
    <div class="item_sipka_dole3-cell"></div>
    <div class="item_sipka_dole4-cell"></div>
    


   <div class="text1">HeartBalance spojuje pohyb a zodpovědnost. Naše podložky vznikají v chráněné dílně na Valašsku a dávají práci lidem s handicapem.</div>
    <div class="text2">Produkty</div>
     <div class="text3">BALANCECORE</div>
    <div class="text4">BALANCEFIT</div>
     <div class="text5">Tvrdá čtvercová podložka pro intenzivní posilování pro  fitness nadšence.</div>
     <div class="text6">Univerzální čtvercová podložka pro jógu, stabilizaci a dostupné cvičení.</div>
    
    
    <div class="JSME">JSME</div>
    <div class="text8">Vyrábíme cvičební podložky, které pomáhají lidem nacházet rovnováhu v pohybu, <br>v mysli i v životě.Každý kus vzniká v chráněné dílně na Valašsku, kde dáváme práci lidem s fyzickým <br>a psychickým handicapem.Naše produkty nejsou jen o výkonu, ale i o respektu, lidskosti a poctivé české výrobě.Proto věříme, že když se staráme <br>o rovnováhu těla, pomáháme vytvářet <br>i vyrovnanější společnost.
</div>

    <div class="Obr"></div>

    
   
 <!--- Click script--->  
<model-viewer 
  src="Imiges/Podlozka.glb"
  alt="3D model"
  id="viewer1"
  class="model"
  camera-orbit="0deg 90deg 90deg"
  exposure="0.5"
  shadow-intensity="5"
  environment-rotation="0deg 120deg 0deg"

  disable-zoom
  rotation-per-second="30deg">
</model-viewer>

<script>
  const viewer1 = document.querySelector('#viewer1');
  viewer1.addEventListener('click', () => {
    window.location.href = 'detail.html';
  });
</script>


<model-viewer
  src="Imiges/Podlozka.glb"
  alt="3D model"
  id="viewer2"
  class="model2"
  camera-orbit="0deg 90deg 90deg"
  exposure="0.5
  "
  shadow-intensity="5"
  environment-rotation="0deg 120deg 0deg"
  disable-zoom>
  
</model-viewer>

<!--- Click script--->
<script>
  const viewer2 = document.querySelector('#viewer2');
  viewer2.addEventListener('click', () => {
    window.location.href = 'detail.html';
  });
</script>
    
  
</div>      

  
  
  
    <div class="grid-container2"></div>

      <svg class="grid-overlay" width="100%" height="100%">
      <!-- body se budou generovat JS -->
      </svg>
</div>
  
  <script>
const viewer3 = document.querySelector('#viewer1');
const viewer4 = document.querySelector('#viewer2');

viewer1.autoRotate = false;
viewer2.autoRotate = false;

window.addEventListener('scroll', () => {
  const scrollFraction = window.scrollY / (document.body.scrollHeight - window.innerHeight);
  const xRotation = scrollFraction * 90;

  viewer1.cameraOrbit = `${-xRotation}deg 90deg 90deg`;
  viewer2.cameraOrbit = `${xRotation}deg 90deg 90deg`;

  viewer1.jumpCameraToGoal();
  viewer2.jumpCameraToGoal();
});
</script>


  <script>
    const container = document.querySelector('.grid-container');

    const totalCells = 27; // celkový počet buněk 
    const existingCells = container.querySelectorAll('.cell').length;

    const emptyCellsToAdd = totalCells - existingCells;

    for (let i = 0; i < emptyCellsToAdd; i++) {
      const emptyCell = document.createElement('div');
      emptyCell.classList.add('cell', 'empty');
      container.appendChild(emptyCell);
    }
  </script>

<script>
  (function(){
    const container2 = document.querySelector('.grid-container2');
    if (!container2) return console.warn('grid-container2 not found');

    // Determine columns from CSS (responsive). Fallback to 12/12 layout.
    const cols = window.matchMedia('(max-width: 600px)').matches ? 6 : 12;
    const rows = 18;
    const totalCells2 = cols * rows;

    // Clear any existing cell2 children (avoid duplicates on hot-reload)
    container2.innerHTML = '';

    // place a dot into every cell2
    for (let i = 0; i < totalCells2; i++) {
      const emptyCell = document.createElement('div');
      emptyCell.classList.add('cell2', 'empty2');

      const dot = document.createElement('div');
      dot.classList.add('dot');
      // mark with data-index to help debugging or per-dot control later
      dot.setAttribute('data-index', i);
      emptyCell.appendChild(dot);

      container2.appendChild(emptyCell);
    }

    // debug: log result
    const placed = container2.querySelectorAll('.dot').length;
    console.log('grid-container2 cells:', totalCells2, 'dot placed:', placed);

    // Draw circles at the corners (4-way intersections) using the SVG overlay
    const svg = document.querySelector('.grid-overlay');
    function drawIntersections() {
      if (!svg) return;
      // clear previous
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      // set SVG to full page scrollable height so dots cover entire page
      const wrapper = document.querySelector('.grid-wrapper');
      if (wrapper) {
        const fullHeight = wrapper.scrollHeight;
        svg.setAttribute('height', String(fullHeight));
      }

      // bounding rects to compute positions
      const gridRect = container2.getBoundingClientRect();
      const svgRect = svg.getBoundingClientRect();

      const cellW = gridRect.width / cols;
      const cellH = gridRect.height / rows;

      // calculate how many rows fit in the full SVG height (entire page including scroll)
      const svgHeight = parseFloat(svg.getAttribute('height')) || gridRect.height;
      const dynamicRows = Math.ceil(svgHeight / cellH) + 1; // +1 for safety margin

      // place circles at internal intersections (where 4 cells meet)
      // that is dynamicRows-1 by cols-1 points (skip outer border if desired)
      const radius = 0; // mini size in pixels
      for (let r = 1; r < dynamicRows; r++) {
        for (let c = 1; c < cols; c++) {
          const cx = gridRect.left + c * cellW - svgRect.left;
          const cy = r * cellH;
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', String(cx));
          circle.setAttribute('cy', String(cy));
          circle.setAttribute('r', String(radius));
          circle.setAttribute('fill', '#ffffff');
          circle.setAttribute('opacity', '1');
          circle.setAttribute('class', 'intersection-dot');
          svg.appendChild(circle);
        }
      }
    }

    // initial draw and on resize (debounced)
    drawIntersections();
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(drawIntersections, 120);
    });
  })();
</script>



</body>
</html>
